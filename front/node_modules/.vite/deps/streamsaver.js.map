{
  "version": 3,
  "sources": ["../../streamsaver/StreamSaver.js"],
  "sourcesContent": ["/*! streamsaver. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\n\n/* global chrome location ReadableStream define MessageChannel TransformStream */\n\n;((name, definition) => {\n  typeof module !== 'undefined'\n    ? module.exports = definition()\n    : typeof define === 'function' && typeof define.amd === 'object'\n      ? define(definition)\n      : this[name] = definition()\n})('streamSaver', () => {\n  'use strict'\n\n  const global = typeof window === 'object' ? window : this\n  if (!global.HTMLElement) console.warn('streamsaver is meant to run on browsers main thread')\n\n  let mitmTransporter = null\n  let supportsTransferable = false\n  const test = fn => { try { fn() } catch (e) {} }\n  const ponyfill = global.WebStreamsPolyfill || {}\n  const isSecureContext = global.isSecureContext\n  // TODO: Must come up with a real detection test (#69)\n  let useBlobFallback = /constructor/i.test(global.HTMLElement) || !!global.safari || !!global.WebKitPoint\n  const downloadStrategy = isSecureContext || 'MozAppearance' in document.documentElement.style\n    ? 'iframe'\n    : 'navigate'\n\n  const streamSaver = {\n    createWriteStream,\n    WritableStream: global.WritableStream || ponyfill.WritableStream,\n    supported: true,\n    version: { full: '2.0.5', major: 2, minor: 0, dot: 5 },\n    mitm: 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0'\n  }\n\n  /**\n   * create a hidden iframe and append it to the DOM (body)\n   *\n   * @param  {string} src page to load\n   * @return {HTMLIFrameElement} page to load\n   */\n  function makeIframe (src) {\n    if (!src) throw new Error('meh')\n    const iframe = document.createElement('iframe')\n    iframe.hidden = true\n    iframe.src = src\n    iframe.loaded = false\n    iframe.name = 'iframe'\n    iframe.isIframe = true\n    iframe.postMessage = (...args) => iframe.contentWindow.postMessage(...args)\n    iframe.addEventListener('load', () => {\n      iframe.loaded = true\n    }, { once: true })\n    document.body.appendChild(iframe)\n    return iframe\n  }\n\n  /**\n   * create a popup that simulates the basic things\n   * of what a iframe can do\n   *\n   * @param  {string} src page to load\n   * @return {object}     iframe like object\n   */\n  function makePopup (src) {\n    const options = 'width=200,height=100'\n    const delegate = document.createDocumentFragment()\n    const popup = {\n      frame: global.open(src, 'popup', options),\n      loaded: false,\n      isIframe: false,\n      isPopup: true,\n      remove () { popup.frame.close() },\n      addEventListener (...args) { delegate.addEventListener(...args) },\n      dispatchEvent (...args) { delegate.dispatchEvent(...args) },\n      removeEventListener (...args) { delegate.removeEventListener(...args) },\n      postMessage (...args) { popup.frame.postMessage(...args) }\n    }\n\n    const onReady = evt => {\n      if (evt.source === popup.frame) {\n        popup.loaded = true\n        global.removeEventListener('message', onReady)\n        popup.dispatchEvent(new Event('load'))\n      }\n    }\n\n    global.addEventListener('message', onReady)\n\n    return popup\n  }\n\n  try {\n    // We can't look for service worker since it may still work on http\n    new Response(new ReadableStream())\n    if (isSecureContext && !('serviceWorker' in navigator)) {\n      useBlobFallback = true\n    }\n  } catch (err) {\n    useBlobFallback = true\n  }\n\n  test(() => {\n    // Transferable stream was first enabled in chrome v73 behind a flag\n    const { readable } = new TransformStream()\n    const mc = new MessageChannel()\n    mc.port1.postMessage(readable, [readable])\n    mc.port1.close()\n    mc.port2.close()\n    supportsTransferable = true\n    // Freeze TransformStream object (can only work with native)\n    Object.defineProperty(streamSaver, 'TransformStream', {\n      configurable: false,\n      writable: false,\n      value: TransformStream\n    })\n  })\n\n  function loadTransporter () {\n    if (!mitmTransporter) {\n      mitmTransporter = isSecureContext\n        ? makeIframe(streamSaver.mitm)\n        : makePopup(streamSaver.mitm)\n    }\n  }\n\n  /**\n   * @param  {string} filename filename that should be used\n   * @param  {object} options  [description]\n   * @param  {number} size     deprecated\n   * @return {WritableStream<Uint8Array>}\n   */\n  function createWriteStream (filename, options, size) {\n    let opts = {\n      size: null,\n      pathname: null,\n      writableStrategy: undefined,\n      readableStrategy: undefined\n    }\n\n    let bytesWritten = 0 // by StreamSaver.js (not the service worker)\n    let downloadUrl = null\n    let channel = null\n    let ts = null\n\n    // normalize arguments\n    if (Number.isFinite(options)) {\n      [ size, options ] = [ options, size ]\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else if (options && options.highWaterMark) {\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else {\n      opts = options || {}\n    }\n    if (!useBlobFallback) {\n      loadTransporter()\n\n      channel = new MessageChannel()\n\n      // Make filename RFC5987 compatible\n      filename = encodeURIComponent(filename.replace(/\\//g, ':'))\n        .replace(/['()]/g, escape)\n        .replace(/\\*/g, '%2A')\n\n      const response = {\n        transferringReadable: supportsTransferable,\n        pathname: opts.pathname || Math.random().toString().slice(-6) + '/' + filename,\n        headers: {\n          'Content-Type': 'application/octet-stream; charset=utf-8',\n          'Content-Disposition': \"attachment; filename*=UTF-8''\" + filename\n        }\n      }\n\n      if (opts.size) {\n        response.headers['Content-Length'] = opts.size\n      }\n\n      const args = [ response, '*', [ channel.port2 ] ]\n\n      if (supportsTransferable) {\n        const transformer = downloadStrategy === 'iframe' ? undefined : {\n          // This transformer & flush method is only used by insecure context.\n          transform (chunk, controller) {\n            if (!(chunk instanceof Uint8Array)) {\n              throw new TypeError('Can only write Uint8Arrays')\n            }\n            bytesWritten += chunk.length\n            controller.enqueue(chunk)\n\n            if (downloadUrl) {\n              location.href = downloadUrl\n              downloadUrl = null\n            }\n          },\n          flush () {\n            if (downloadUrl) {\n              location.href = downloadUrl\n            }\n          }\n        }\n        ts = new streamSaver.TransformStream(\n          transformer,\n          opts.writableStrategy,\n          opts.readableStrategy\n        )\n        const readableStream = ts.readable\n\n        channel.port1.postMessage({ readableStream }, [ readableStream ])\n      }\n\n      channel.port1.onmessage = evt => {\n        // Service worker sent us a link that we should open.\n        if (evt.data.download) {\n          // Special treatment for popup...\n          if (downloadStrategy === 'navigate') {\n            mitmTransporter.remove()\n            mitmTransporter = null\n            if (bytesWritten) {\n              location.href = evt.data.download\n            } else {\n              downloadUrl = evt.data.download\n            }\n          } else {\n            if (mitmTransporter.isPopup) {\n              mitmTransporter.remove()\n              mitmTransporter = null\n              // Special case for firefox, they can keep sw alive with fetch\n              if (downloadStrategy === 'iframe') {\n                makeIframe(streamSaver.mitm)\n              }\n            }\n\n            // We never remove this iframes b/c it can interrupt saving\n            makeIframe(evt.data.download)\n          }\n        } else if (evt.data.abort) {\n          chunks = []\n          channel.port1.postMessage('abort') //send back so controller is aborted\n          channel.port1.onmessage = null\n          channel.port1.close()\n          channel.port2.close()\n          channel = null\n        }\n      }\n\n      if (mitmTransporter.loaded) {\n        mitmTransporter.postMessage(...args)\n      } else {\n        mitmTransporter.addEventListener('load', () => {\n          mitmTransporter.postMessage(...args)\n        }, { once: true })\n      }\n    }\n\n    let chunks = []\n\n    return (!useBlobFallback && ts && ts.writable) || new streamSaver.WritableStream({\n      write (chunk) {\n        if (!(chunk instanceof Uint8Array)) {\n          throw new TypeError('Can only write Uint8Arrays')\n        }\n        if (useBlobFallback) {\n          // Safari... The new IE6\n          // https://github.com/jimmywarting/StreamSaver.js/issues/69\n          //\n          // even though it has everything it fails to download anything\n          // that comes from the service worker..!\n          chunks.push(chunk)\n          return\n        }\n\n        // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transferable streams solves this...\n        channel.port1.postMessage(chunk)\n        bytesWritten += chunk.length\n\n        if (downloadUrl) {\n          location.href = downloadUrl\n          downloadUrl = null\n        }\n      },\n      close () {\n        if (useBlobFallback) {\n          const blob = new Blob(chunks, { type: 'application/octet-stream; charset=utf-8' })\n          const link = document.createElement('a')\n          link.href = URL.createObjectURL(blob)\n          link.download = filename\n          link.click()\n        } else {\n          channel.port1.postMessage('end')\n        }\n      },\n      abort () {\n        chunks = []\n        channel.port1.postMessage('abort')\n        channel.port1.onmessage = null\n        channel.port1.close()\n        channel.port2.close()\n        channel = null\n      }\n    }, opts.writableStrategy)\n  }\n\n  return streamSaver\n})\n"],
  "mappings": "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",
  "names": []
}
